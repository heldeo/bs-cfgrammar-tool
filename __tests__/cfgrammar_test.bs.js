// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Cfgrammar = require("../src/cfgrammar.bs.js");
var CfgrammarTool = require("./../node_modules/cfgrammar-tool");

var cfgrammar_js = CfgrammarTool;

Jest.describe("Types submodule, Symbol, Rule and equality functionality", (function (param) {
        Jest.test("Returns Symbol Object", (function (param) {
                return Jest.Expect.toBe(true, Jest.Expect.expect(Cfgrammar.equals(/* `Sym */[
                                    4154599,
                                    Cfgrammar.Types.sym("NT", "A")
                                  ], /* `Sym */[
                                    4154599,
                                    Cfgrammar.Types.sym("NT", "A")
                                  ])));
              }));
        Jest.test("Return Non-terminal (NT) with string passed into constructor", (function (param) {
                var eq = Cfgrammar.equals(/* `Sym */[
                      4154599,
                      Cfgrammar.Types.nt("A")
                    ], /* `Sym */[
                      4154599,
                      Cfgrammar.Types.nt("A")
                    ]);
                return Jest.Expect.toBe(true, Jest.Expect.expect(eq));
              }));
        Jest.test("Return Terminal (T)  with string passed into constructor", (function (param) {
                return Jest.Expect.toBe(true, Jest.Expect.expect(Cfgrammar.equals(/* `Sym */[
                                    4154599,
                                    Cfgrammar.Types.t("A")
                                  ], /* `Sym */[
                                    4154599,
                                    (cfgrammar_js.types.T("A"))
                                  ])));
              }));
        Jest.test("Rule creation with input: (E,  [T(a),NT(B)] )", (function (param) {
                var prod_rules = [
                  Cfgrammar.Types.t("a"),
                  Cfgrammar.Types.nt("B")
                ];
                return Jest.Expect.toBe(true, Jest.Expect.expect(Cfgrammar.equals(/* `Rule */[
                                    915186972,
                                    Cfgrammar.Types.rule("E", prod_rules)
                                  ], /* `Rule */[
                                    915186972,
                                    (cfgrammar_js.types.Rule("E",prod_rules))
                                  ])));
              }));
        return Jest.test("Tests reduction (string in grammar)", (function (param) {
                      [
                        Cfgrammar.Types.t("a"),
                        Cfgrammar.Types.nt("B")
                      ];
                      var rules = [
                        Cfgrammar.Types.rule("S", [
                              Cfgrammar.Types.t("a"),
                              Cfgrammar.Types.nt("B")
                            ]),
                        Cfgrammar.Types.rule("S", [Cfgrammar.Types.t("a")]),
                        Cfgrammar.Types.rule("B", [])
                      ];
                      var grammar = Cfgrammar.grammar(rules, "S");
                      var did_parse = Cfgrammar.Parse.length(Cfgrammar.Parse.parse(grammar, "a"));
                      return Jest.Expect.toBe(true, Jest.Expect.expect(did_parse > 0));
                    }));
      }));

exports.cfgrammar_js = cfgrammar_js;
/* cfgrammar_js Not a pure module */
